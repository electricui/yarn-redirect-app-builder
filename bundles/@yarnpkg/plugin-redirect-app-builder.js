/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-redirect-app-builder",
factory: function (require) {
var plugin=(()=>{var A=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var J=Object.getOwnPropertyNames;var G=Object.prototype.hasOwnProperty;var p=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var X=(t,e)=>{for(var r in e)A(t,r,{get:e[r],enumerable:!0})},q=(t,e,r,a)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of J(e))!G.call(t,i)&&i!==r&&A(t,i,{get:()=>e[i],enumerable:!(a=K(e,i))||a.enumerable});return t};var Q=t=>q(A({},"__esModule",{value:!0}),t);var ne={};X(ne,{default:()=>se});var V=p("@yarnpkg/core");var n=p("@yarnpkg/fslib"),f=p("@yarnpkg/core"),M=p("@yarnpkg/libzip"),v=class{supports(e,r){return!!e.reference.startsWith("appbuilder:")}getLocalPath(e,r){return null}async fetch(e,r){let a=new n.NodeFS,{zipPackage:i}=await this.fetchPrebuild(e,r),s=i.getRealPath();await n.xfs.chmodPromise(s,420);let o=`${r.cache.cacheKey}/${e.locatorHash}`,c=r.cache.getLocatorPath(e,o);if(r.cache.markedFiles.add(c),!c)throw new Error("Assertion failed: Expected the cache path to be available");await n.xfs.mkdirpPromise(n.ppath.dirname(c)),await n.xfs.movePromise(s,c);let m,g=()=>new M.ZipFS(c,{baseFs:a,readOnly:!0}),d=new n.LazyFS(()=>f.miscUtils.prettifySyncErrors(()=>m=g(),k=>`Failed to open the cache entry for ${f.structUtils.prettyLocator(r.project.configuration,e)}: ${k}`),n.ppath);return{packageFs:new n.AliasFS(c,{baseFs:d,pathUtils:n.ppath}),releaseFs:()=>{m?.discardAndClose()},prefixPath:f.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,r),checksum:o}}async fetchPrebuild(e,r){let a=await n.xfs.mktempPromise(),i=n.ppath.join(a,"prebuilt.zip"),s=f.structUtils.getIdentVendorPath(e),o=new M.ZipFS(i,{create:!0});return await o.mkdirpPromise(s),await new n.CwdFS(s,{baseFs:o}).writeJsonPromise("package.json",{name:f.structUtils.slugifyLocator(e),preferUnplugged:!0}),o.saveAndClose(),{zipPackage:o}}};var y=p("@yarnpkg/core"),D=class{supportsDescriptor(e,r){return!!e.range.startsWith("appbuilder:")}supportsLocator(e,r){return!!e.reference.startsWith("appbuilder:")}shouldPersistResolution(e,r){return!1}bindDescriptor(e,r,a){return e}getResolutionDependencies(e,r){return{}}async getCandidates(e,r,a){if(!a.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");return[y.structUtils.makeLocator(y.structUtils.parseIdent("app-builder-bin"),e.range)]}async getSatisfying(e,r,a,i){let[s]=await this.getCandidates(e,r,i);return{locators:a.filter(o=>o.locatorHash===s.locatorHash),sorted:!1}}async resolve(e,r){let a=e.reference.match(new RegExp("appbuilder<(.*)>"));if(!a)throw new Error("Could not decode app-builder-bin version");return{...e,version:a[1],languageName:r.project.configuration.get("defaultLanguageName"),linkType:y.LinkType.HARD,dependencies:new Map,peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:new Map}}};var R=p("@yarnpkg/core");var S=p("@yarnpkg/fslib"),l=p("@yarnpkg/core");var x=p("@yarnpkg/fslib");function E(){switch(process.arch){case"arm":return"armv7l";default:return process.arch}}var O=async(t,e,r,a)=>{if(a.cancel)return;let i=await t.readdirPromise(e);await Promise.all(i.map(async s=>{if(a.cancel)return;let o=x.ppath.join(e,s),c=await t.statPromise(o);c.isDirectory()?await O(t,o,r,a):c.isFile()&&await r(t,o)}))};var $=p("@yarnpkg/libzip"),I=p("stream"),U=p("@yarnpkg/libzip"),u=p("@yarnpkg/fslib"),C=p("fs");function Y(t,e){for(let[r,a]of Object.entries(e))t=t.replace(new RegExp(`{${r}}`,"g"),a);return t}var ee="1";async function te(t,e,r,a){if(await t.existsPromise(e)){let i=(await t.readFilePromise(e)).toString(),s=u.ppath.join(r,"bin",process.platform==="win32"?"app-builder.exe":"app-builder");if(!await t.existsPromise(s))return!1;let o=!1;if(await t.accessPromise(s,C.constants.X_OK).then(()=>{o=!0}).catch(c=>{o=!1}),!o)return!1;if(i===a)return!0}return!1}async function N(t,e,r){let{packageLocation:a,packageFs:i}=await re(t,e);t.version=t.version.replace("npm%3A","");let s=e.configuration.get("redirectAppBuilderTemplate"),o=Y(s,{platform:process.platform,arch:process.arch}),c=`${ee}/${o}-${t.version}-${process.platform}-${E()}`.replace(/\//g,"-"),m=u.ppath.join(a,".cache_key");if(await te(i,m,a,c)){r.report.reportInfo(l.MessageName.UNNAMED,`${o} cache keys match, skipping installation`);return}let g=l.structUtils.makeLocator(l.structUtils.makeDescriptor(l.structUtils.parseIdent(o),t.version),`npm:${t.version}`),d=e.configuration.makeFetcher(),P;try{P=await d.fetch(g,{cache:r.cache,checksums:e.storedChecksums,report:r.report,project:e,fetcher:d})}catch(b){throw console.error(b),b}let w={cancel:!1},k=null;if(await l.miscUtils.releaseAfterUseAsync(async()=>{await O(P.packageFs,".",async(b,F)=>{F.endsWith("package.json")&&(k=F,w.cancel=!0)},w)}),!k)throw new Error(`Could not find package.json in ${o}`);let W=u.ppath.dirname(k);w.cancel=!1,await l.miscUtils.releaseAfterUseAsync(async()=>{await O(P.packageFs,".",async(b,F)=>{let Z=await b.readFilePromise(F),_=F.replace(W,"."),L=u.ppath.join(a,_);await i.mkdirpPromise(u.ppath.dirname(L)),await i.writeFilePromise(L,Z),u.ppath.basename(u.ppath.dirname(L))==="bin"&&await i.chmodPromise(L,493)},w)},P.releaseFs),await i.writeFilePromise(m,c),r.report.reportInfo(l.MessageName.UNNAMED,`Installed ${o} over ${l.structUtils.stringifyLocator(t)}`)}async function re(t,e){let r=e.storedPackages.get(t.locatorHash);if(!r)throw new Error(`Package for ${l.structUtils.prettyLocator(e.configuration,t)} not found in the project`);return await $.ZipOpenFS.openPromise(async a=>{let i=e.configuration,s=e.configuration.getLinkers(),o={project:e,report:new l.StreamReport({stdout:new I.PassThrough,configuration:i})},c=s.find(d=>d.supportsPackage(r,o));if(!c)throw new Error(`The package ${l.structUtils.prettyLocator(e.configuration,r)} isn't supported by any of the available linkers`);let m=await c.findPackageLocation(r,o),g=new S.CwdFS(m,{baseFs:a});return{packageLocation:m,packageFs:g}},{libzip:await(0,U.getLibzipPromise)()})}function ae(t){return t.name==="app-builder-bin"&&t.scope===null}async function oe(t,e){for(let r of t.storedPackages.values())if(ae(r)){try{await N(r,t,e)}catch(a){e.report.reportInfo(R.MessageName.UNNAMED,`Couldn't mutate ${R.structUtils.stringifyLocator(r)}`),console.error(a)}break}}async function T(t,e){await e.report.startTimerPromise("Build utility resolution",async()=>{await oe(t,e)})}var h=p("@yarnpkg/core"),j={"3.5.10":"3.5.11"},z=async(t,e,r,a,i)=>{if(t.name==="app-builder-bin"&&t.scope===null){let s=j[t.range]?j[t.range]:t.range,o=h.structUtils.makeDescriptor(t,h.structUtils.makeRange({protocol:"appbuilder:",source:h.structUtils.stringifyDescriptor(t),selector:`appbuilder<${s}>`,params:null}));return i.resolveOptions.report.reportInfo(h.MessageName.UNNAMED,`Found a dependency to replace: ${h.structUtils.stringifyDescriptor(t)}`),o}return t};var B=p("@yarnpkg/core");async function H(t,e){e(B.structUtils.parseDescriptor("app-builder-bin@*",!0),{preferUnplugged:!0})}var ie={fetchers:[v],resolvers:[D],hooks:{afterAllInstalled:T,registerPackageExtensions:H,reduceDependency:z},configuration:{redirectAppBuilderTemplate:{description:"The template to build the replacement app-builder-bin dependency",type:V.SettingsType.STRING,default:"@electricui/app-builder-bin-{platform}-{arch}"}}},se=ie;return Q(ne);})();
return plugin;
}
};
